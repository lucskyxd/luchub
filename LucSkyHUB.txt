local RemoteLogger = {
    Logs = {},
    MaxLogs = 1000,  -- Limite máximo de logs armazenados
    OutputToConsole = true,
    OutputToUI = false  -- Pode ser ativado para mostrar em uma SurfaceGui
}

-- Cria uma UI simples se quiser visualização in-game
local function createLoggerUI()
    local screenGui = Instance.new("ScreenGui")
    local frame = Instance.new("Frame")
    local scroller = Instance.new("ScrollingFrame")
    local layout = Instance.new("UIListLayout")
    
    -- Configuração básica da UI
    screenGui.Name = "RemoteEventLoggerUI"
    screenGui.Parent = game.Players.LocalPlayer:WaitForChild("PlayerGui")
    
    frame.Size = UDim2.new(0.4, 0, 0.5, 0)
    frame.Position = UDim2.new(0.6, 0, 0.25, 0)
    frame.BackgroundTransparency = 0.7
    frame.Parent = screenGui
    
    scroller.Size = UDim2.new(1, 0, 1, 0)
    scroller.CanvasSize = UDim2.new(1, 0, 0, 0)
    scroller.Parent = frame
    
    layout.Parent = scroller
    layout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
        scroller.CanvasSize = UDim2.new(0, 0, 0, layout.AbsoluteContentSize.Y)
    end)
    
    RemoteLogger.OutputUI = scroller
end

-- Formata os argumentos para exibição
local function formatArgs(...)
    local args = {...}
    local formatted = {}
    
    for i, v in ipairs(args) do
        local vType = typeof(v)
        local display
        
        if vType == "table" then
            display = "{...} (table)"
        elseif vType == "function" then
            display = "function"
        elseif vType == "userdata" then
            display = tostring(v)
        else
            display = string.format("%q", tostring(v))
        end
        
        table.insert(formatted, string.format("[%d]: %s (%s)", i, display, vType))
    end
    
    return formatted
end

-- Registra uma chamada de RemoteEvent
function RemoteLogger:logCall(remote, args)
    local logEntry = {
        Timestamp = DateTime.now():FormatLocalTime("HH:mm:ss", "pt-BR"),
        RemoteName = remote.Name,
        RemotePath = remote:GetFullName(),
        Arguments = args,
        Formatted = formatArgs(unpack(args))
    }
    
    -- Adiciona ao histórico
    table.insert(self.Logs, 1, logEntry)
    if #self.Logs > self.MaxLogs then
        table.remove(self.Logs)
    end
    
    -- Saída para console
    if self.OutputToConsole then
        print(string.format("\n[%s] %s chamado:", logEntry.Timestamp, logEntry.RemotePath))
        for _, line in ipairs(logEntry.Formatted) do
            print("  "..line)
        end
    end
    
    -- Saída para UI
    if self.OutputToUI and self.OutputUI then
        local textLabel = Instance.new("TextLabel")
        textLabel.Text = string.format("[%s] %s (%d args)", 
            logEntry.Timestamp, logEntry.RemoteName, #args)
        textLabel.TextXAlignment = Enum.TextXAlignment.Left
        textLabel.Size = UDim2.new(1, 0, 0, 30)
        textLabel.Parent = self.OutputUI
    end
    
    return logEntry
end

-- Hooking dos RemoteEvents
function RemoteLogger:startMonitoring()
    local remotes = game:GetService("ReplicatedStorage"):FindFirstChild("Remotes") or
                   game:GetService("ReplicatedStorage"):FindFirstChild("RemoteEvents") or
                   game:GetService("ReplicatedStorage")
    
    -- Monitora eventos existentes
    for _, remote in ipairs(remotes:GetDescendants()) do
        if remote:IsA("RemoteEvent") then
            self:hookRemoteEvent(remote)
        end
    end
    
    -- Monitora novos eventos
    remotes.DescendantAdded:Connect(function(child)
        if child:IsA("RemoteEvent") then
            self:hookRemoteEvent(child)
            print("[Logger] Novo RemoteEvent detectado:", child:GetFullName())
        end
    end)
end

-- Aplica hook a um RemoteEvent específico
function RemoteLogger:hookRemoteEvent(remote)
    local oldFire = remote.FireServer
    
    remote.FireServer = function(self, ...)
        local args = {...}
        self:logCall(remote, args)
        return oldFire(self, unpack(args))
    end
    
    print("[Logger] Monitorando:", remote:GetFullName())
end

-- Exporta logs para texto formatado
function RemoteLogger:exportLogs()
    local output = "-- Log de RemoteEvents --\n\n"
    
    for i, log in ipairs(self.Logs) do
        output = output .. string.format("[%s] %s\n", log.Timestamp, log.RemotePath)
        for _, arg in ipairs(log.Formatted) do
            output = output .. "  " .. arg .. "\n"
        end
        output = output .. "\n"
    end
    
    -- Cria um arquivo de texto local (simulado)
    local export = Instance.new("StringValue")
    export.Name = "RemoteEventLogs_" .. os.time()
    export.Value = output
    export.Parent = game:GetService("ReplicatedStorage")
    
    print("\n=== LOGS EXPORTADOS ===\n")
    print("Copie o conteúdo abaixo ou pegue o StringValue em ReplicatedStorage")
    print(output)
    
    return output
end

-- Inicialização
if not _G.RemoteEventLogger then
    _G.RemoteEventLogger = RemoteLogger
    RemoteLogger:startMonitoring()
    
    -- Ativa UI se necessário
    if RemoteLogger.OutputToUI then
        createLoggerUI()
    end
    
    print("\n=== MONITORAMENTO ATIVADO ===")
    print("Use _G.RemoteEventLogger:exportLogs() para exportar")
end

return RemoteLogger
